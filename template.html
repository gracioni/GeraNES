<!doctype html>
<html lang="en-us">
  <head>

    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>GeraNES</title>
    <link rel="icon" href="geranes.ico" type="image/x-icon">
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <style>

      /* garante que 100% do documento está definido */
      html, body { height: 100%; margin: 0; padding: 0; }

      /* emscripten border usa --vh para evitar incluir barras móveis do navegador */
      .emscripten_border {
        width: 100vw;
        /* usa a variável --vh atualizada por JS (compat fallback: 1vh) */
        height: calc(var(--vh, 1vh) * 100);
        overflow: hidden;
      }

      canvas.emscripten {
        width: 100%;
        height: 100%;
        display: block; /* remove gaps */
      }

      /* FULLSCREEN OVERLAY (simplified loading screen) */

      #overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        pointer-events: none;
      }

      #overlay .inner {
        pointer-events: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.6rem;
        padding: 1.2rem 1.6rem;
        background: rgba(0,0,0,0.35);
        border-radius: 8px;
        color: #fff;
        min-width: 220px;
      }

      .spinner {
        height: 50px;
        width: 50px;
        animation: spin 0.8s linear infinite;
        border-left: 8px solid rgb(0,150,240);
        border-right: 8px solid rgb(0,150,240);
        border-bottom: 8px solid rgb(0,150,240);
        border-top: 8px solid rgb(100,0,200);
        border-radius: 50%;
      }

      @keyframes spin {
        from { transform: rotate(0deg); }
        to   { transform: rotate(360deg); }
      }

    </style>
  </head>

  <body>

    <!-- LOADING OVERLAY -->
    <div id="overlay">
      <div class="inner">
        <div class="spinner"></div>
        <div id="statusText" style="font-size:1.1rem; font-weight:700;">
          Downloading...
        </div>
      </div>
    </div>

    <div class="emscripten_border">
      <canvas id="canvas" class="emscripten"
              oncontextmenu="event.preventDefault()"
              tabindex="-1"
              style="visibility:hidden;"></canvas>
    </div>

    <script type="text/javascript">

      // --- viewport height fix for mobile (keeps the same behavior you had antes)
      function updateVh() {
        // calcula 1% da altura visível real e guarda em --vh
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      }
      // roda inicialmente e em eventos que alteram a barra/endereço móvel
      updateVh();
      window.addEventListener('resize', updateVh);
      window.addEventListener('orientationchange', updateVh);
      // opcional: em alguns browsers a rolagem muda a chrome UI, atualizar ao scroll também ajuda
      window.addEventListener('scroll', updateVh);

      // Wake Lock (mantido)
      let wakeLock = null;
      async function requestWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
          }
        } catch (e) {
          // falha silenciosa — apenas log
          console.error(e);
        }
      }
      requestWakeLock();
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === "visible") requestWakeLock();
      });

      // Overlay elements
      var overlay = document.getElementById("overlay");
      var statusText = document.getElementById("statusText");
      var canvas = document.getElementById("canvas");

      // Module object (simplified loading)
      var Module = {
        canvas: canvas,

        setStatus: function(text) {
          if (text) statusText.textContent = text;
        },

        onRuntimeInitialized: function() {
          overlay.style.display = "none";
          canvas.style.visibility = "visible";
          try { canvas.focus(); } catch(_){}
        }
      };

      Module.setStatus("Downloading...");

      window.onerror = () => {
        Module.setStatus("Exception thrown, see console");
      };

    </script>

    <!-- IMPORT/EXPORT FS (mantive seu código original, sem alterações funcionais) -->
    <script>

    // Import zip into root '/' (will overwrite existing files)
    async function importEntireFSFromZip(fileOrBlob) {
      if (typeof FS === 'undefined') {
        console.error('Emscripten FS is not yet available.');
        throw new Error('FS not available');
      }

      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

      if (!fileOrBlob) {
        return new Promise((resolve, reject) => {
          let input = document.getElementById("fsImportInput");
          if (!input) {
            input = document.createElement("input");
            input.type = "file";
            input.accept = ".zip";
            input.id = "fsImportInput";
            input.style.display = "none";
            document.body.appendChild(input);
          }

          const onChange = async (ev) => {
            input.removeEventListener("change", onChange);
            const f = ev.target.files[0];
            input.value = "";
            if (!f) {
              resolve(false);
              return;
            }
            try {
              await importEntireFSFromZip(f);
              resolve(true);
            } catch (e) {
              reject(e);
            }
          };

          input.addEventListener("change", onChange, { once: true });
          input.click();
        });
      }

      const zip = await JSZip.loadAsync(fileOrBlob);

      function sanitize(path) {
        return path
          .replace(/^\/+/, "")
          .split("/")
          .filter((x) => x !== "" && x !== "..")
          .join("/");
      }

      const entries = Object.keys(zip.files);
      const filesToVerify = [];

      for (const name of entries) {
        const clean = sanitize(name);
        if (!clean) continue;
        const full = "/" + clean;
        const entry = zip.files[name];

        if (entry.dir) {
          try { FS.mkdirTree(full); } catch (_) {}
        } else {
          const data = await entry.async("uint8array");

          const dir = full.substring(0, full.lastIndexOf("/"));
          if (dir) {
            try { FS.mkdirTree(dir); } catch (_) {}
          }

          try { FS.unlink(full); } catch (_) {}
          FS.writeFile(full, data, { encoding: "binary" });

          filesToVerify.push(full);
        }
      }

      if (typeof FS.syncfs === "function") {
        await new Promise((res, rej) =>
          FS.syncfs(true, (err) => (err ? rej(err) : res()))
        );
      }

      const maxRetries = 5;
      const retryDelayMs = 200;
      let attempt = 0;

      while (attempt <= maxRetries) {
        let missing = [];

        for (const p of filesToVerify) {
          try {
            FS.stat(p);
          } catch (e) {
            missing.push(p);
          }
        }

        if (missing.length === 0) {
          return true;
        }

        attempt++;
        if (attempt > maxRetries) {
          const example = missing.slice(0,5);
          const err = new Error(`Import incomplete: ${missing.length} files missing. Example: ${example.join(', ')}`);
          console.error(err);
          throw err;
        }

        await sleep(retryDelayMs);
      }

      return true;
    }

    // Export entire MEMFS → zip
    async function exportEntireFS(filename = "geranes_session.zip") {
      if (typeof FS === 'undefined' || typeof JSZip === 'undefined') {
        console.error('Export unavailable (FS or JSZip missing).');
        return;
      }

      if (typeof FS.syncfs === 'function') {
        try {
          await new Promise((res, rej) =>
            FS.syncfs(false, err => err ? rej(err) : res())
          );
        } catch (_) {}
      }

      const zip = new JSZip();

      function isSkippablePath(path) {
        return path.startsWith('/proc') ||
               path.startsWith('/dev') ||
               path.startsWith('/sys');
      }

      function walk(path) {
        let entries;
        try {
          entries = FS.readdir(path);
        } catch (_) { return; }

        for (const name of entries) {
          if (name === '.' || name === '..') continue;

          const full = path === '/' ? `/${name}` : `${path}/${name}`;

          if (isSkippablePath(full)) continue;

          let stat;
          try {
            stat = FS.stat(full);
          } catch (_) { continue; }

          const isDir = (stat.mode & 0o040000) !== 0;

          if (isDir) {
            walk(full);
          } else {
            try {
              const data = FS.readFile(full, { encoding:'binary' });
              const zipName = full.replace(/^\/+/, '');
              zip.file(zipName, data);
            } catch (_) {
              continue;
            }
          }
        }
      }

      walk('/');

      try {
        const blob = await zip.generateAsync(
          { type: 'blob' },
          (meta) => console.log(`Compressing... ${Math.round(meta.percent)}%`)
        );

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

      } catch (e) {
        console.error('Export failed.', e);
      }
    }

    </script>

    {{{ SCRIPT }}}

  </body>
</html>
